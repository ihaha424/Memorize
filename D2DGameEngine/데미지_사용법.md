# 데미지 사용법

## 함수 설명

데미지와 관련된 모든 함수들은 `Actor` 클래스에 정의 되어 있음.
따라서, 데미지 관련 로직들은 `Actor` 클래스에서 오버라이딩을 통해 구현 가능.

***

먼저, 데미지를 받기 위한 주요 함수인 `TakeDamage()` 를 살펴봅시다.

```cpp
/**
 * @brief Actor가 데미지를 받습니다.
 * @param damageAmount 받은 데미지의 양
 * @param damageEvent 데미지 이벤트의 정보
 * @param eventInstigator 데미지를 준 컨트롤러 (예시., 보스 컨트롤러 혹은 플레이어 컨트롤러)
 * @param damageCauser 데미지를 준 액터
 * @return 실제로 받은 데미지의 양
 */
float TakeDamage(float damageAmount, struct DamageEvent const& damageEvent, class Controller* eventInstigator, Actor* damageCauser);
```

- `damageAmount`에 대해서는 밑에 함수 설명하면서 다시 확인.
- `damageEvent`도 밑에서 자세히 설명. 지금은 그냥 데미지의 자세한 정보를 담는 구조체라고 보면 됨.
- `eventInstigator`는 사실 우리 게임에서 필요 없음. 이건 어떤 플레이어가 데미지를 가했는지 게임 내에서 확인 하기 위해 필요한 파라미터. 
예를 들어, FPS 게임에서 플레이어 A 가 수류탄을 던져서 플레이어 B 를 잡았다면, `eventInstigator` 변수에 플레이어 A 의 컨트롤러가 넘겨져야함. 
- `damageCauser`는 어떤 액터가 데미지를 가했는지 확인하는 파라미터. 바로 위의 예시에서, `damageCauser`는 수류탄에 해당.

***

`InternalTakeDamage` 함수는 `TakeDamage` 함수의 헬퍼 함수로써, `damageAmount`로 들어온 데미지의 양에 액터의 스탯을 적용하여 데미지를 계산해 줍니다. 
예시로, 롤에서 어떤 챔피언이 A라는 챔피언에 100의 데미지를 가했다면, A 챔피언이 실제로 받는 데미지는 다양한 변수에 의해 100보다 적거나 많은 수 있습니다.
본인이 람머스라서 방어력이 높아 기본 공격에 받는 데미지의 90% 만 받는다고 가정합시다. 
그러면, `InternalTakeDamage`에서 방어력을 계산해서 만약 `DamageEventType`이 기본 공격일 경우, 90% 감소된 데미지를 반환합니다. 
혹은, 만약 증오의 사슬을 걸어 놓은 적한테 피해를 입었다면 `InternalTakeDamage` 함수에서 `eventInstigator`를 비교해서 감소된 피해량을 반환합니다.

```cpp
/**
 * @brief `TakeDamage` 함수를 통해 들어온 데미지를 실제 받은 데미지의 양으로 환산해주는 함수.
 * @param damageAmount 받은 데미지의 양
 * @param damageEvent 데미지 정보
 * @param eventInstigator 데미지를 준 컨트롤러
 * @param damageCauser 데미지를 준 액터
 * @return 실제로 받은 데미지의 양
 */
virtual float InternalTakeDamage(float damageAmount, struct DamageEvent const& damageEvent, class Controller* eventInstigator, Actor* damageCauser) { return damageAmount; }
```

***

`OnTakeDamage`는 `TakeDamage` 함수 호출 시, 만약 `InternalTakeDamage`에 의해 계산된 데미지의 양이 0보다 클 때 실행되는 이벤트 함수 입니다.
액터를 상속받아 `OnTakeDamage` 함수를 오버라이딩 하면, 데미지 이벤트가 발생했을 때, 다양한 커스텀 행동들을 실행 할 수 있습니다.

```cpp
/**
 * @brief 데미지를 받았을 때 실행되는 이벤트 함수.
 * @param damageAmount 실제로 받은 데미지의 양
 * @param damageEvent 데미지 정보
 * @param eventInstigator 데미지를 준 컨트롤러
 * @param damageCauser 데미지를 준 액터
 */
virtual void OnTakeDamage(float damageAmount, struct DamageEvent const& damageEvent, class Controller* eventInstigator, Actor* damageCauser) {}
```

## 예시

### 박쥐의 공격

먼저, 박쥐 액터를 만들어 줍시다.

박쥐 액터 안에, 박쥐의 공격 패턴, 데미지 정보를 맴버 변수로 선언함으로서 매 공격 틱마다 번거롭게 박쥐의 데미지 정보를 생성하는 수고를 덜어줍시다.

```cpp

clss Bat : public Actor
{
	using Super = Actor;	// 본인의 부모 클래스 엘리어스

	// 박쥐의 상태 애니메이션
	class AnimationBitmapComponent* moveAnimation{ nullptr };	// 움직임 애니메이션
	class AnimationBitmapComponent* attackAnimation{ nullptr };	// 공격 애니메이션

	class Player* player{ nullptr };	// 계속 플레이어를 따라다녀야 하니, 매 틱마다 찾을 필요 없게 변수로 넣어둡니다.

	// 본인 스탯
	float speed{ 250.f };	// 초당 250 픽셀

	// 데미지 정보 (리플렉션 가능)
	float damageAmount{ 5.f };	// 공격력
	float attackRange{ 100.f };	// 공격 범위
	float attackSpeed{ 1.f };		// 공격 속도
	PointDamageEvent batDamageEvent	// 말이 이벤트지 그냥 박쥐 공격 정보 넘기는 구조체

public:
	Bat(World* world);

	// 플레이어는 `BeginPlay()` 함수에서 찾아 줍니다.
	void BeginPlay() override;
	// 박쥐가 따라다니면서 공격하는 로직은 `Update()`에서 구현해 줍니다.
	void Update(float _dt) override;
}

```

***

다음으로 생성자 안에서 박쥐의 충돌체, 애니메이션 비트맵, 그리고 데미지 정보를 세팅해 줍니다.

```cpp
Bat::Bat(World* _world) : Actor(_world)
{
	SetTickProperties(TICK_PHYSICS | TICK_PRE_UPDATE | TICK_UPDATE | TICK_POST_UPDATE | TICK_RENDER);

	// 충돌체는 원
	CircleComponent* circle = CreateComponent<CircleComponent>();
	circle->collisionProperty = CollisionProperty(CollisionPropertyPreset::DynamicOverlapAll);	// 액터가 형태가 변하고, 전부 오버랩 발생
	circle->bGenerateOverlapEvent = true;	// 오버랩 이벤트가 필요합니다.
	circle->maxSpeed = speed;	// 속도가 박쥐의 속도를 넘어가지 않게 최대 속력을 설정해줍니다.
	rootComponent = circle;		// 충돌체가 루트

	// 움직임 애니메이션
	moveAnimation = CreateComponent<AnimationBitmapComponent>();
	moveAnimation->SetSprite(L"TestResource/Boss/Bat/Idle/Bat_Idle.png");
	moveAnimation->SliceSpriteSheet(32, 32, 0, 0, 0, 0);	// 스프라이트 시트 짜르고
	moveAnimation->SetFrameDurations({ 0.125 });	// 매 프레임이 0.125초
	moveAnimation->isVisible = true;	// 렌더링 가능
	moveAnimation->SetLoop(true);			// 루프 애니메이션 입니다.
	rootComponent->AddChild(moveAnimation);

	// 공격 애니메이션
	attackAnimation = CreateComponent<AnimationBitmapComponent>();
	attackAnimation->SetSprite(L"TestResource/Boss/Bat/Attack/Bat_Attack.png");
	attackAnimation->SliceSpriteSheet(32, 32, 0, 0, 0, 0);
	attackAnimation->SetFrameDurations({ 0.125 });
	attackAnimation->isVisible = false;	// 공격할 때만 보이게 만들거니까 처음에는 `isVisible`은 `false`
	attackAnimation->SetLoop(false);		// 공격 때만 재생하고 끌껍니다.
	rootComponent->AddChild(attackAnimation);

	// 데미지 타입
	DamageType damageType{
		.damageImpulse = 10000.f,	// 공격을 가하면 액터에 10000의 충격량을 가합니다.
	};
	batDamageEvent.SetDamageType(damageType);	// 데미지 타입을 세팅합니다. 데미지 타입은 Setter 함수 내부에서 특별하게 처리됩니다.
	batDamageEvent.damage = damageAmount;	// 데미지의 양	
}
```

***

플레이어는 다음의 에러를 방지하기 위해서 `BeginPlay()`에서 찾습니다.
만약, 월드가 생기면서 박쥐와 플레이어가 동시에 생성된다고 가정해 봅시다. 이런 경우 박쥐의 생성자에서 플레이어를 찾게 되면,
박쥐가 플레이어보다 ***먼저*** 생성되는 경우, `nullptr` 에러가 발생하게 됩니다.
따라서, 모든 오브젝트가 월드에 다 생성이 된 이후인, `BeginPlay()` 함수에서 플레이어를 찾아야 위와 같은 로직 에러를 막을 수 있습니다.

```cpp
void Bat::BeginPlay()
{
	Super::BeginPlay();	// 부모 클래스의 `BeginPlay()` 함수를 실행합니다.

	moveAnimation->Trigger(true);	// 움직임 애니메이션을 실행해 줍시다.
	player = GetWorld()->FindActorByType<Player>();	// 월드에서 플레이어를 찾아줍니다.
}
```

***

마지막으로 공격 로직입니다. `player->TakeDamage(...);` 함수에 주목해 주세요.

```cpp
void Bat::Update(float _dt)
{
	// 공격 모션이 공격 애니메이션 시작후 0.5초 후에 나가니까 누적 시간 처음 값을 0.5f에 맞춰놓습니다. 
	static float elapsedTime = 0.50f;	// 공격속도를 맞추기 위해 시간 누적이 필요합니다.
	Super::Update(_dt);	// 부모 클래스의 업데이트

	// 플레이어의 위치를 확인 한 후, 
	// 플레이어까지의 거리와 방향을 구해줍시다. 
	Math::Vector2 playerLocation = player->GetLocation();
	Math::Vector2 toPlayer = playerLocation - GetLocation();	// 플레이어까지의 방향
	float distanceToPlayerSquared = toPlayer.LengthSquared();	// 플레이어까지의 거리
	toPlayer.Normalize();

	// 플레이어 위치에 따른 애니메이션 플리핑
	// 플레이어가 본인 왼쪽에 있으면 왼쪽을 향하게 애니메이션 플립
	// 오른쪽이면 원래 애니메이션 출력
	if (toPlayer.x >= 0) 
	{
		moveAnimation->FlipX(false);
		attackAnimation->FlipX(false);
	}
	else 
	{
		moveAnimation->FlipX(true);
		attackAnimation->FlipX(true);
	}

	// 공격 애니메이션이 실행되는지를 확인하는 걸로 상태 변환을 체크합니다.
	// 공격 애니메이션이 1초 짜리라서 공격속도랑 싱크가 맞습니다.
	if (attackAnimation->IsPlaying()) 
	{
		elapsedTime += _dt;
		if (elapsedTime >= attackSpeed)	// 1초 마다 공격을 가합니다.
		{
			// 박쥐가 공격하는 방향을 설정해 줍니다. 충격량 계산에 사용됩니다.
			batDamageEvent.shotDirection = toPlayer;

			// 충격을 받은 컴포넌트를 알려줍니다. 충격량 적용에 사용됩니다.
			// 보통은 공격받은 객체의 루트 컴포넌트를 넘겨주면 됩니다.
			batDamageEvent.hitInfo.hitComponent = (PrimitiveComponent*) player->rootComponent;

			// 플레이어가 데미지를 받습니다.
			player->TakeDamage(damage, batDamageEvent, nullptr, this);

			// elapsedTime에서 1초를 빼서
			// 공격을 여러번 하지 않게 조정해줍니다.
			elapsedTime -= attackSpeed;
		}
	}
	else // 공격 애니메이션이 끝났습니다.
	{
		// 만약 공격 애니메이션이 바로 끝난 직후라면 
		// 움직임 애니메이션을 켜줍니다.
		if (!moveAnimation->IsPlaying())
		{
			moveAnimation->Trigger(true);	// 움직임 애니메이션 시작
			moveAnimation->isVisible = true;	// 다시 렌더링 가능

			attackAnimation->Trigger(false);	// 공격 애니메이션 중단
			attackAnimation->isVisible = false;	// 렌더링 끔

			elapsedTime = 0.50f;	// 누적 시간 다시 초기값
		}

		// 만약 플레이어가 공격 범위안에 들어오면
		if (distanceToPlayerSquared <= attackRange * attackRange)
		{
			moveAnimation->Trigger(false);	// 움직임 애니메이션 중단
			moveAnimation->isVisible = false;	// 렌더링 끔

			attackAnimation->Trigger(true);	// 공격 애니메이션 시작
			attackAnimation->isVisible = true;	// 렌더링 가능

			SetVelocity(Math::Vector2::Zero);	// 공격할 때는 움직이지 않습니다.
		}
		else
		{
			AddVelocity(toPlayer * speed);	// 플레이어를 추격합니다.
		}
	}
}
```

***

이제 진짜 중요한 부분인, 플레이어가 데미지를 받는 로직을 만들어 봅시다.

정말 간단하게, `OnTakeDamage()` 함수만 오버로딩 해주면 끝입니다.

애초에, 충격랑이나 복잡한 로직들은 `TakeDamage()` 함수에 이미 구현되어 있으니, 다른 부분은 신경 쓸 필요 없습니다.

```cpp

class Player : public Actor
{
	// 다른 맴버 변수들 ...

	float health{ 100.f }	// 체력!

	// ...

public:
	Player(World* _world);

	// ...

	void OnTakeDamage(float damageAmount, struct DamageEvent const& damageEvent, class Controller* eventInstigator, Actor* damageCauser) override
	{
		health -= damageAmount;	// 체력을 받은 데미지 만큼 감소시킵니다.

		if (health <= 0.f)	// 만약 체력이 0보다 작거나 같다면,
		{
			isDead = true;	// 사망합니다.
			NotifyPlayerDeath();	// 사망 이벤트 알리는 함수?
		}
	}
}

```

### 장판 스킬의 틱 공격

이번 예시에서는 데미지 타입을 활용해 보고, 범위 공격 이벤트를 발생시키는 로직을 만들어 봅니다.

데미지 타입이란 말그대로 데미지가 어떠한 종류의 공격을 가하는지에 대한 타입 정보 그 자체입니다.
예를 들어, 불 데미지 타입을 만들어 플레이어가 불 데미지를 받으면 불이 붙게 만들려면.

먼저 `DamageType`을 상속받아, `DamageType_Fire`을 만들어 준 후, 구조체에 불 공격에 대한 정보를 담습니다.
그리고, 불이 공격을 가할 때, 일반 DamageType 대신 DamageType_Fire을 데미지 이벤트에 바인딩 해서 넘기면, 
플레이어가 불공격을 받았을 때의 특수한 이벤트 처리를 할 수 있게 됩니다.

이번 예시에서는 `DamageType_Darkness` 라는 데미지 타입을 만들고, 플레이어가 어둠 공격 속성은 무시하게 만듭니다.

***

장판 스킬 액터를 만들고, 플레이어에 공격을 가해봅니다.

```cpp
class TormentedShadow : public Actor
{
	float damageAmountOnTick{ 5.f }; // 틱 당 데미지
	float tickInterval{ 1.f };	 // 1 틱은 1초
	float radius{ 250.f };		 // 장판 반지름
	RadialDamageEvent tormentedShadowDamageEvent;	// 데미지 정보
	std::list<Actor*> overlappedActors;

public:
	TormentedShadow(World* _world);
	
	// 겹쳐 있으면 공격합니다.
	void OnBeginOverlap(Actor* other) override;
	// 더이상 겹쳐있지 않으면 공격을 취소합니다.
	void OnEndOverlap(Actor* other) override;

	void Update(float _dt) override;
}
```

***

다음으로 공격 정보를 세팅해 줍시다.

```cpp
TormentedShadow::TormentedShadow(World* _world) : Actor(_world)
{
	CircleComponent* circle = CreateComponent<CircleComponent>();
	circle->InitCircleRadius(radius);
	circle->collisionProperty = CollisionProperty(CollisionPropertyPreset::OverlapAll);
	circle->bGenerateOverlapEvent = true;
	circle->maxSpeed = 0.f;	// 움직이지 않습니다.
	rootComponent = circle;

	// 비트맵 세팅
	BitmapComponent* bitmap = CreateComponent<BitmapComponent>();
	// ...

	// 공격 타입 세팅
	// 공격 타입은 어둠
	DamageType_Darkness damageType;	// 기본 생성자에서 알아서 데미지 타입을 세팅해줍니다.
	tormentedShadowDamageEvent.SetDamageType(damageType);

	// 범위 공격 정보를 세팅합니다.
	RadialDamageInfo damageInfo(
		damageType,
		damageAmountOnTick,	// 최소 데미지와 최대 데미지는 동일합니다.
		damageAmountOnTick,
		0.f,	// 데미지 감소율; 0 이면 감소 없음, 1 이면 선형으로 감소, 2 이면 기하급수
		0.f,	// 최소 반지름
		radius	// 최대 반지름
	);
	tormentedShadowDamageEvent.radialDamageInfo = damageInfo;
}
```

***

이제 오버랩 이벤트 콜백에서 데미지 이벤트를 발생시킵니다.

```cpp
void TormentedShadow::OnBeginOverlap(Actor* actor)
{
	if (actor)
	{
		// 정보 받고 타이머 시작.
		tormentedShadowDamageEvent.origin = GetLocation();
		Timer setTimer(actor->TakeDamage(damageAmountOnTick, tormentedShadowDamageEvent, nullptr, this), tickInterval);
	}
}
```

그리고, 오버랩이 끝나면 타이머를 끕니다.

```cpp
void TormentedShadow::OnEndOverlap(Actor* actor)
{
	if (actor)
	{
		// 타이머 찾아다 끄기.
	}
}
```

***

다음으로 플레이어가 데미지를 받을 때, 어둠 속성의 공격은 무시하게끔 만들어 봅시다.

```cpp

class Player : public Actor
{
	// 다른 맴버 변수들 ...

	float health{ 100.f }	// 체력!

	// ...

public:
	Player(World* _world);

	// ...

	void OnTakeDamage(float damageAmount, struct DamageEvent const& damageEvent, class Controller* eventInstigator, Actor* damageCauser) override
	{
		// 어둠 속성이면 무시.
		if (damageEvent.GetDamageType() == EDamageType::Darkness)
		{
			return;
		}

		health -= damageAmount;	// 체력을 받은 데미지 만큼 감소시킵니다.

		if (health <= 0.f)	// 만약 체력이 0보다 작거나 같다면,
		{
			isDead = true;	// 사망합니다.
			NotifyPlayerDeath();	// 사망 이벤트 알리는 함수?
		}
	}
}

```

## 공격 이벤트 설명

공격 이벤트의 구조에 대한 설명입니다. 사실 이벤트라기 보다는 공격 정보를 담는 구조체에 가깝습니다.
그런데도 이벤트 클래스를 상속받은 이유는 고유의 이벤트 ID를 생성하고, 나중에 이벤트 버스로 처리를 가능하게 하기 위함입니다.

현재, 데미지 이벤트 타입은 3가지 밖에 없습니다.

* 기본 공격 (DamageEvent)
* 포인트 공격 (PointDamageEvent)
* 범위 공격 (RadialDamageEvent)

기본 공격은 말그대로 기본적인 공격 데미지 이벤트 타입입니다. 데미지가 어떤 타입인지와 같은 간단한 정보만 담고 있습니다.

두 번째로 포인트 공격은 단일 공격과 동일합니다. 보통은 FPS 게임에서 총을 쐈을 때, 레이캐스팅을 통해서 가해진 데미지를 포인트 공격 이벤트로 처리합니다.
보통은, 공격이 들어온 방향, 레이캐스팅 히트 결과 등의 정보를 담습니다.

마지막으로 범위 공격은 장판형 공격에 사용됩니다. 보통은 FPS 게임에서 수류탄으로 가해진 데미지를 범위 공격 이벤트로 처리합니다. 이벤트 구조체 안에는 
`RadialDamageInfo`라는 범위 공격 정보를 담는 특수한 구조체를 가지고 있습니다. 
`RadialDamageInfo`는 최대 데미지, 최소 데미지, 데미지 감소율, 최소 반지름, 최대 반지름의 정보를 담고 있으며, 구조체 자체의 맴버 함수인 
`GetDamageScale(float _중심으로부터의_거리)` 이라는 함수를 통해서 데미지 감소율을 적용한 데미지의 결과값을 반환할 수 있습니다.
그 외, 범위 공격 이벤트는 범위 공격의 진원지, 영향을 받은 액터의 컴포넌트 등의 정보를 담을 수 있습니다. 
